{"componentChunkName":"component---src-templates-blog-post-js","path":"/how-to-use-autocompletion-in-vim/","result":{"data":{"site":{"siteMetadata":{"title":"Lual Dev"}},"markdownRemark":{"id":"b0886086-bfde-503d-bc91-4ed108113936","excerpt":"One of the coolest features that can make you more productive with Vim is autocompletion. As with anything else, there are many plugins for this topic, but they…","html":"<p>One of the coolest features that can make you more productive with Vim is autocompletion.</p>\n<p>As with anything else, there are many plugins for this topic, but they toolset that Vim offers out of the box in this regard is powerful on its own.</p>\n<p>In this post, we’ll be taking a look at how to navigate, accept or reject completion suggestions, and when and how to use each of the submodes that allow you to complete a particular type of words.</p>\n<h2>Basic Usage</h2>\n<p>You can access completion mode using <code class=\"language-text\">^X</code> (<kbd>CTRL</kbd> + <kbd>X</kbd>) either in <em>insert mode</em> or in <em>replace mode</em>.</p>\n<p>Inside this mode you can:</p>\n<ul>\n<li>Select the type of completion you want to perform (the usual thing to do).</li>\n<li>Scroll up and down using <code class=\"language-text\">^Y</code> for scrolling one line up and <code class=\"language-text\">^E</code> for scrolling one line down (just like you’d do in normal mode).</li>\n<li>Keep writing to come back to the regular insert mode.</li>\n</ul>\n<p>When you pick the type of completion you want to use, a popup will appear displaying the available completion options, and you can execute any of the following actions:</p>\n<ul>\n<li>Navigate through the completion options using <code class=\"language-text\">^P</code> (<strong>p</strong>revious) and <code class=\"language-text\">^N</code> (<strong>n</strong>ext). Alternatively, you can use the same hotkey combination that you used to enter the submode (<code class=\"language-text\">^]</code>, <code class=\"language-text\">^F</code>, etc.) instead of <code class=\"language-text\">^N</code>, except for <code class=\"language-text\">^I</code>.</li>\n<li>Accept the selected suggestion using <code class=\"language-text\">^Y</code> (<strong>y</strong>es) or just continuing typing. Alternatively, you can use <code class=\"language-text\">&lt;ESC&gt;</code>, but it will also exit insert mode.</li>\n<li>Reject the selected suggestion and exit completion mode using <code class=\"language-text\">^E</code> (<strong>e</strong>xit).</li>\n</ul>\n<p>In the following sections we’ll be taking a deeper dive into each of the completion types available.</p>\n<h2>Completing Whole Lines</h2>\n<p>Hitting <code class=\"language-text\">^L</code> in completion mode will open a popup with a list of full lines that start with the same characters in the current line before the cursor.</p>\n<p>Options considered for completion will include all possible matches in all opened buffers (files), even if they’re not part of the current tab, and the display order is backwards starting from the previous line.</p>\n<h2>Complete Words Found in Current Buffer</h2>\n<p>If the word that you want to complete is already found in the file you’re editing, you can use <code class=\"language-text\">^P</code>, or <code class=\"language-text\">^N</code> to get a popup with all possible completion options.</p>\n<p>The only difference between <code class=\"language-text\">^P</code> and <code class=\"language-text\">^N</code> is the search order, which is forwards for <code class=\"language-text\">^N</code> (<strong>n</strong>ext words) and backwards for <code class=\"language-text\">^P</code> (<strong>p</strong>revious words). Notice that, regardless of the search direction, the set of matches is the same since continues searching until it gets back to the current word, regardless of having hit the end or the beginning of the document while searching.</p>\n<h2>Complete Words Using Matches in a Dictionary</h2>\n<p>You can set up one or several lists of words to be used as your dictionary sources for completion. To do so:</p>\n<ol>\n<li>Create the file(s) containing the dictionary. For more details on the format of this file check out <code class=\"language-text\">:h dictionary</code>.</li>\n<li>\n<p>Set the <code class=\"language-text\">dictionary</code> variable in your <code class=\"language-text\">.vimrc</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token comment\">\" you can add more separating the paths with commas</span>\n<span class=\"token keyword\">set</span> <span class=\"token builtin\">dictionary</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token builtin\">path</span><span class=\"token operator\">/</span><span class=\"token keyword\">to</span><span class=\"token operator\">/</span>your<span class=\"token operator\">/</span><span class=\"token builtin\">dictionary</span><span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>Enter dictionary completion mode using <code class=\"language-text\">^X</code> to access completion mode and then <code class=\"language-text\">^K</code> for the dictionary completion option.</li>\n</ol>\n<h2>Complete Words Using Matches in a Thesaurus</h2>\n<p>This option is analogous to the dictionary option. To use it:</p>\n<ol>\n<li>Create the file(s) containing the thesaurus. For more details on the format of this file check out <code class=\"language-text\">:h thesaurus</code>.</li>\n<li>\n<p>Set the <code class=\"language-text\">thesaurus</code> variable in your <code class=\"language-text\">.vimrc</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token comment\">\" you can add more separating the paths with commas</span>\n<span class=\"token keyword\">set</span> <span class=\"token builtin\">thesaurus</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token builtin\">path</span><span class=\"token operator\">/</span><span class=\"token keyword\">to</span><span class=\"token operator\">/</span>your<span class=\"token operator\">/</span><span class=\"token builtin\">thesaurus</span><span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>Enter the thesaurus completion mode using <code class=\"language-text\">^X</code> to access completion mode and then <code class=\"language-text\">^T</code> for the thesaurus completion option.</li>\n</ol>\n<h2>Complete Words Using Matches in Current File and Imports/Includes</h2>\n<p>An <em>included file</em> is any file from which you’re importing functions, classes and other identifiers to be used in the current file.</p>\n<p>The term originates from the syntax used by C to import programming objects from another file, however the tern doesn’t only refer to C includes, but also refers to Node’s ”<code class=\"language-text\">require</code>s”, Python’s ”<code class=\"language-text\">import</code>s” and in general any file whose names get imported using whatever syntax is available in the language being used.</p>\n<p>A common completion use case is expanding the names available in the included files. To use this type of completion, you need to follow these steps:</p>\n<ol>\n<li>\n<p>Set the <code class=\"language-text\">include</code> variable to a search pattern used to find include/import commands. Since the syntax used for <em>included files</em> will vary depending on the language, you may want to set the variable using an auto command (<code class=\"language-text\">:h au</code>) that gets executed only when files written in a specific language are being opened. For instance, for Node projects written in a style where all imports are handled using <code class=\"language-text\">require(&lt;module&gt;)</code>, you could use something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\">au FileType javascript <span class=\"token keyword\">set</span> <span class=\"token builtin\">include</span><span class=\"token operator\">=</span><span class=\"token function\">require</span><span class=\"token punctuation\">(</span></code></pre></div>\n</li>\n<li>Set the <code class=\"language-text\">path</code> variable to a pattern matching the paths of the directories containing the <em>included files</em>. You can use <code class=\"language-text\">:checkpath</code> to verify that all included files were found.</li>\n<li>Enter the included files completion mode using <code class=\"language-text\">^X^I</code> in insert or replace mode.</li>\n</ol>\n<h2>Complete Words Using Tags</h2>\n<p>A <em>tag</em> is an identifier used to label program objects such as functions, methods, and classes.</p>\n<p>Tags are located in a <em>tags file</em> that can be generated for a project running the following command from the root directory of the project:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ctags -R .</code></pre></div>\n<p>After creating the tags file, you can access the tag completion submode using <code class=\"language-text\">^X^]</code>.</p>\n<h2>Complete File Names</h2>\n<p>This type of completion is useful for writing import statements and I/O statements fast.</p>\n<p>Enter <code class=\"language-text\">^X^F</code> in insert or replace mode to access this completion submode, a popup will show the available file name options to complete the word you started typing.</p>\n<p>Notice that:</p>\n<ul>\n<li>Options available are based on the current working directory <em>in Vim</em> (which may be different from the current working directory in the terminal where Vim is being run). Use <code class=\"language-text\">:pwd</code> to know the value of this directory.</li>\n<li>The <code class=\"language-text\">path</code> variable is not involved in this type of completion as of Vim 8.0.</li>\n</ul>\n<h2>Complete Definitions or Macros</h2>\n<p>Use this completion mode if you’re interested in completing the identifier of a macro (while working on a file written in a language that supports macros) or a similar definition.</p>\n<p>You access this submode using <code class=\"language-text\">^X^D</code> in insert or replace mode, and you can modify what Vim considers a definition, by changing the value of the pattern in the variable <code class=\"language-text\">define</code>.</p>\n<p>A common customization of <code class=\"language-text\">define</code> is changing the pattern to include <em>const</em> type declarations.</p>\n<h2>Complete Vim Commands</h2>\n<p>This type of completion is useful when writing Vim scripts since it allows you to complete any valid Vim command, including commands\nadded by installed plugins.</p>\n<p>Access this completion type using <code class=\"language-text\">^X^V</code> in insert or replace mode.</p>\n<h2>Complete Words Using Intelligent Code Completion</h2>\n<p>Vim also allows you to complete words depending on the context, offering completion suggestions based not only on the text written in the current file and imported files, but also based on the namespace available <em>for the language being used</em>.</p>\n<p>The official name of this feature inside Vim is <em>omni completion</em>, it’s usually not enabled by default, but all you need to activate it is to add the following two lines to your <code class=\"language-text\">.vimrc</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token keyword\">filetype</span> plugin <span class=\"token keyword\">on</span>\n<span class=\"token keyword\">set</span> <span class=\"token builtin\">omnifunc</span><span class=\"token operator\">=</span>syntaxcomplete#Complete</code></pre></div>\n<p>and then just access it using <code class=\"language-text\">^X^O</code> in insert or replace mode.</p>\n<p>Most common languages are supported, however, if a language you’re using isn’t supported yet or if you want to customize the behavior of the omni completion used for a particular language, you can set the <code class=\"language-text\">omnifunc</code> variable to override the function used for this type of completion. For example, you could use an auto command to set the omni function value for a specific filetype as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\">au FileType <span class=\"token punctuation\">{</span><span class=\"token keyword\">filetype</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">set</span> <span class=\"token builtin\">omnifunc</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>custom omni <span class=\"token keyword\">function</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Complete Words Using Spelling Suggestions</h2>\n<p>If the <code class=\"language-text\">spell</code> option is active (<code class=\"language-text\">:set spell</code>), you can complete words in the language used for spelling correction using <code class=\"language-text\">^X^S</code> or <code class=\"language-text\">^Xs</code> in insert or replace mode.</p>\n<p>Notice that:</p>\n<ul>\n<li>⚠️ <kdb>CTRL</kdb> + <kdb>S</kdb> suspends display in many Unix terminals. Don’t panic if you did it by accident! You can reactivate your display using <kdb>CTRL</kdb> + <kdb>Q</kdb> 😉.</li>\n<li>If there’s a spelling error in the line you’re editing, the cursor will jump to the misspelled word and the options available for completion will be based on that word instead of the word you were initially editing when you entered this submode.</li>\n</ul>\n<h2>Complete Words Using Custom Function</h2>\n<p>If none of the default completion types satisfies your needs, you can create your own completion function and access it using <code class=\"language-text\">^X^U</code>(<strong>u</strong>ser defined completion) in insert or replace mode. All you need to do is to create a function that matches the format defined in the documentation (<code class=\"language-text\">:h complete-functions</code>), and then set the <code class=\"language-text\">completefunc</code> value to your custom function:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token comment\">\" .vimrc</span>\n<span class=\"token keyword\">set</span> <span class=\"token builtin\">completefunc</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>your custom <span class=\"token keyword\">function</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>Vim completion mode is a powerful tool that can increase your productivity when writing code. Completion options cover most of the common use cases and if you need anything extra, tweaking the basic options or extending them is fairly easy to do.</p>\n<h2>References</h2>\n<ul>\n<li><code class=\"language-text\">:h ins-completion</code>.</li>\n<li><a href=\"https://www.reddit.com/r/vim/wiki/include-and-path\"><em>Include and Path</em> on Vim Reddit Wiki</a>.</li>\n<li><a href=\"https://vim.fandom.com/wiki/Omni_completion\"><em>Omni completion</em> on Vim Fandom Wiki</a></li>\n</ul>","frontmatter":{"title":"How to Use Autocompletion in Vim","date":"November 30, 2020","description":"A comprehensive guide covering all completion modes available in Vim."}},"previous":{"fields":{"slug":"/how-to-use-emojis-with-vim/"},"frontmatter":{"title":"How to Use Emojis with Vim"}},"next":null},"pageContext":{"id":"b0886086-bfde-503d-bc91-4ed108113936","previousPostId":"0ebab2e9-6408-5e08-8ec8-d0d9149fba7f","nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}